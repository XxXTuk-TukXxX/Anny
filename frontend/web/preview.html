<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Annotate — PDF Preview</title>

  <!-- Fonts & Icons -->
  <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin />
  <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?display=swap&family=Inter:wght@400;500;700;900&family=Noto+Sans:wght@400;500;700;900" onload="this.rel='stylesheet'">
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet"/>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
  <link rel="stylesheet" href="assets/css/preview.css" />

  <!-- PDF.js disabled in browser mode; server-rendered images are used instead -->
  
</head>

<body class="bg-gray-50 text-gray-900">
  <div class="relative flex min-h-screen flex-col overflow-x-hidden">
    
    <!-- Header -->
    <header class="flex items-center justify-between border-b border-gray-200 px-6 py-4">
      <div class="flex items-center gap-3">
        <svg class="h-8 w-8 text-[var(--primary-color)]" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <path d="M8.58 8.58A22.5 22.5 0 1 0 39.42 8.58L24 24 8.58 8.58Z" fill="currentColor"/>
        </svg>
        <h1 class="text-xl font-bold tracking-tight">Anny</h1>
      </div>
      <div class="flex items-center gap-2">
        <button id="btnSettings" title="Settings" class="flex h-10 w-10 items-center justify-center rounded-full text-gray-500 hover:bg-gray-100 hover:text-gray-900">
          <span class="material-symbols-outlined text-2xl">settings</span>
        </button>
        <button title="Help" class="flex h-10 w-10 items-center justify-center rounded-full text-gray-500 hover:bg-gray-100 hover:text-gray-900">
          <span class="material-symbols-outlined text-2xl">help</span>
        </button>
      </div>
    </header>

    <!-- Toolbar -->
    <div id="mainToolbar" class="flex flex-wrap items-center gap-2 border-b border-gray-200 bg-white px-4 py-3">
      <div class="flex items-center gap-2">
        <button id="prevBtn" class="inline-flex items-center gap-1 rounded-md border border-gray-300 bg-white px-3 py-2 text-sm font-medium hover:bg-gray-50">
          <span class="material-symbols-outlined text-base">chevron_left</span> Prev page
        </button>
        <button id="nextBtn" class="inline-flex items-center gap-1 rounded-md border border-gray-300 bg-white px-3 py-2 text-sm font-medium hover:bg-gray-50">
          Next page <span class="material-symbols-outlined text-base">chevron_right</span>
        </button>
        <button id="refreshBtn" class="inline-flex items-center gap-1 rounded-md border border-gray-300 bg-white px-3 py-2 text-sm font-medium hover:bg-gray-50">
          <span class="material-symbols-outlined text-base">refresh</span> Refresh preview
        </button>
        <button id="aiAnnotatePageBtn" class="inline-flex items-center gap-1 rounded-md border border-gray-300 bg-white px-3 py-2 text-sm font-medium hover:bg-gray-50">
          <span class="material-symbols-outlined text-base">auto_awesome</span> AI annotate page
        </button>
        <button id="addBoxBtn" class="inline-flex items-center gap-1 rounded-md border border-gray-300 bg-white px-3 py-2 text-sm font-medium hover:bg-gray-50">
          <span class="material-symbols-outlined text-base">note_add</span> Add text box
        </button>
        <div class="mx-2 h-6 w-px bg-gray-200"></div>
        <div class="flex items-center gap-1" id="zoomControls">
          <button id="zoomOutBtn" title="Zoom out (Ctrl/⌘ -)" class="inline-flex items-center rounded-md border border-gray-300 bg-white px-2 py-2 text-sm hover:bg-gray-50">
            <span class="material-symbols-outlined text-base">zoom_out</span>
          </button>
          <div class="min-w-[4.5rem] select-none text-center text-sm" id="zoomLabel">100%</div>
          <button id="zoomInBtn" title="Zoom in (Ctrl/⌘ +)" class="inline-flex items-center rounded-md border border-gray-300 bg-white px-2 py-2 text-sm hover:bg-gray-50">
            <span class="material-symbols-outlined text-base">zoom_in</span>
          </button>
          <button id="zoomFitBtn" title="Fit to page (Ctrl/⌘ 0)" class="inline-flex items-center rounded-md border border-gray-300 bg-white px-2 py-2 text-sm hover:bg-gray-50">
            <span class="material-symbols-outlined text-base">fit_screen</span>
          </button>
        </div>
      </div>

      <div class="mx-2 h-6 w-px bg-gray-200"></div>

      <label class="inline-flex items-center gap-2 text-sm">
        <input id="freezeToggle" type="checkbox" class="rounded border-gray-300" />
        Freeze layout
      </label>

      <label class="inline-flex items-center gap-2 text-sm">
        <input id="autoToggle" type="checkbox" class="rounded border-gray-300" checked />
        Auto-refresh after drag
      </label>

      <div class="mx-2 h-6 w-px bg-gray-200"></div>

      <div class="flex items-center gap-2 text-sm">
        <button id="exportBtn" class="inline-flex items-center gap-2 rounded-md bg-[var(--primary-color)] px-4 py-2 text-sm font-semibold text-white hover:bg-opacity-90">
          <span class="material-symbols-outlined text-base">picture_as_pdf</span> Export PDF
        </button>
      </div>

      <div class="ml-auto text-xs text-gray-500">
        <span id="pageInfo">Page <span id="pageNum">1</span>/<span id="pageCount">—</span></span>
      </div>
    </div>

    <!-- Edit toolbar (hidden by default) -->
    <div id="editToolbar" class="hidden flex flex-wrap items-center gap-2 border-b border-gray-200 bg-white px-4 py-3">
      <button id="editBackBtn" title="Back" class="inline-flex items-center gap-1 rounded-md border border-gray-300 bg-white px-3 py-2 text-sm hover:bg-gray-50">
        <span class="material-symbols-outlined text-base">arrow_back</span> Back
      </button>
      <div class="mx-2 h-6 w-px bg-gray-200"></div>
      <div class="flex items-center gap-2 text-sm">
        <span class="font-medium">Edit note</span>
        <label class="flex flex-col gap-1 text-sm">
          <span class="font-medium">Text</span>
          <textarea id="editTextInput" rows="4" class="w-[32rem] max-w-[60vw] resize-y rounded-md border-gray-300 px-3 py-2 text-sm" placeholder="Enter note text..."></textarea>
        </label>
        <label class="inline-flex items-center gap-2">
          <span>Color</span>
          <input id="editColorInput" type="color" value="#ff9800" class="h-8 w-10 rounded border border-gray-300"/>
        </label>
        <label class="inline-flex items-center gap-2">
          <span>Font</span>
          <input id="editFontSizeInput" type="number" min="6" step="0.5" value="9" class="w-20 rounded-md border-gray-300 py-1 text-sm"/>
          <span>pt</span>
        </label>
        <button id="saveEditBtn" class="rounded-md bg-[var(--primary-color)] px-3 py-2 text-sm font-semibold text-white">Save</button>
        <button id="cancelEditBtn" class="rounded-md border border-gray-300 bg-white px-3 py-2 text-sm">Cancel</button>
      </div>
      <div class="ml-auto text-xs text-gray-500">
        <span id="editNoteId" class="text-gray-400"></span>
      </div>
    </div>

    <!-- Viewer -->
    <main id="viewerHost" class="flex-1 overflow-auto">
      <div class="mx-auto max-w-7xl p-4">
        <div id="canvasWrap" class="relative mx-auto flex min-h-[70vh] items-center justify-center rounded-xl bg-gray-900 shadow ring-1 ring-gray-800">
          <!-- Canvas + text layer -->
          <canvas id="pdfCanvas" class="max-w-full rounded-lg shadow-lg" style="z-index:10;"></canvas>
          <div id="textLayer" class="absolute pointer-events-none" style="z-index:20;"></div>
          <div id="overlay" class="absolute" style="z-index:30; pointer-events:auto;"></div>
          <img id="imgPage" class="absolute inset-0 m-auto hidden rounded-lg shadow-lg" style="z-index:10; pointer-events:none;" alt="PDF page"/>
        </div>
        
        <!-- Context menu for note actions -->
        <div id="ctxMenu" role="menu" aria-label="Note actions">
          <button id="ctxEditText" role="menuitem">Edit text</button>
          <button id="ctxAddText" role="menuitem">Add text box here</button>
        </div>
        <!-- Removed iframe fallback in favor of rasterized images via backend -->
      </div>
    </main>
  </div>

  <!-- AI annotate-page modal -->
  <div id="aiPageModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="aiPageTitle">
    <div class="modal p-6">
      <div class="flex items-start justify-between gap-4">
        <div>
          <h2 id="aiPageTitle" class="text-lg font-bold text-gray-900">AI annotate this page</h2>
          <p class="mt-1 text-sm text-gray-600">Add more annotations to the current page using your prompt.</p>
        </div>
        <button id="aiPageCloseBtn" type="button" class="inline-flex h-9 w-9 items-center justify-center rounded-full text-gray-500 hover:bg-gray-100 hover:text-gray-900" aria-label="Close">
          <span class="material-symbols-outlined text-xl">close</span>
        </button>
      </div>

      <div id="aiPageError" class="mt-4 hidden rounded-lg border border-red-200 bg-red-50 p-3 text-sm text-red-900"></div>

      <div id="aiPageForm" class="mt-4 space-y-3">
        <label class="block text-sm font-semibold text-gray-800">
          Prompt (optional)
          <textarea
            id="aiPagePrompt"
            rows="3"
            class="mt-2 w-full resize-y rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-[var(--primary-color)] focus:ring-[var(--primary-color)]"
            placeholder="Leave blank to use the original prompt..."
          ></textarea>
        </label>
        <div class="flex flex-wrap items-center justify-between gap-3">
          <button id="aiPageUseOriginalBtn" type="button" class="text-sm font-medium text-blue-700 hover:underline">
            Reset to original prompt
          </button>
          <div class="flex items-center gap-2">
            <button id="aiPageCancelBtn" type="button" class="rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-semibold text-gray-900 hover:bg-gray-50">
              Cancel
            </button>
            <button id="aiPageRunBtn" type="button" class="rounded-md bg-[var(--primary-color)] px-4 py-2 text-sm font-semibold text-white hover:bg-opacity-90">
              Annotate page
            </button>
          </div>
        </div>
      </div>

      <div id="aiPageWorking" class="mt-6 hidden">
        <div class="flex items-center gap-3">
          <div class="h-5 w-5 animate-spin rounded-full border-2 border-gray-300 border-t-[var(--primary-color)]"></div>
          <div class="text-sm font-medium text-gray-800">Annotating page…</div>
        </div>
        <p class="mt-2 text-xs text-gray-500">This may take a few moments.</p>
      </div>
    </div>
  </div>

  <script type="application/json">
    /***** Back-end integration points *****************************************
     * Replace getPreviewUrl() / browseForPath() / exportEditedPdf() with your
     * own logic. For desktop, we try window.pywebview.api if present.
     *************************************************************************/

    async function getPreviewUrl() {
      // Try pywebview first, but wait briefly if it's not ready yet
      const tryApi = async () => {
        try {
          if (window.pywebview?.api?.get_preview_url) {
            return await window.pywebview.api.get_preview_url();
          }
        } catch (e) {
          // fall through to retry / fallback
        }
        return null;
      };

      let url = await tryApi();
      if (!url) {
        const start = Date.now();
        while (Date.now() - start < 2500) { // wait up to 2.5s for injection
          await new Promise(r => setTimeout(r, 150));
          url = await tryApi();
          if (url) break;
        }
      }
      if (url) return url;

      // Fallback demo PDF only if no desktop bridge available
      return "https://unec.edu.az/application/uploads/2014/12/pdf-sample.pdf";
    }

    async function browseForPath(current) {
      if (window.pywebview?.api?.browse_export_path) {
        const p = await window.pywebview.api.browse_export_path(current || "");
        return p || current;
      }
      // Web fallback: just return current (no real file picker for path)
      return current;
    }

    async function exportEditedPdf(targetPath) {
      if (window.pywebview?.api?.export_pdf) {
        return await window.pywebview.api.export_pdf(targetPath);
      }
      alert("Export hook not connected. Implement window.pywebview.api.export_pdf(path).");
      return false;
    }

    async function notifyFreezeLayout(on) {
      if (window.pywebview?.api?.set_freeze_layout) {
        try { await window.pywebview.api.set_freeze_layout(!!on); } catch {}
      }
    }

    /***** PDF.js viewer logic *************************************************/
    const hasPdfJs = !!window.pdfjsLib;
    let useImages = !hasPdfJs; // fallback mode flag
    let pdfDoc = null;
    let pageNum = 1;
    let isRendering = false;
    let pendingPage = null;
    let zoom = 1.0; // user zoom multiplier (1.0 = fit)
    const ZOOM_MIN = 0.5, ZOOM_MAX = 4.0, ZOOM_STEP = 0.1;

    const canvas = document.getElementById('pdfCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    const canvasWrap = document.getElementById('canvasWrap');
    const imgPage = document.getElementById('imgPage');
    const overlay = document.getElementById('overlay');
    let selectedUid = null;

    const $pageNum = document.getElementById('pageNum');
    const $pageCount = document.getElementById('pageCount');
    const $pageInfo = document.getElementById('pageInfo');

    function setPageInfo() {
      if ($pageNum) $pageNum.textContent = String(pageNum);
      if ($pageCount) $pageCount.textContent = pdfDoc ? String(pdfDoc.numPages) : '—';
    }

    async function loadDocument(url) {
      try { console.log('[preview] loadDocument', (url||'').slice(0, 64)); } catch {}
      try {
        if (!useImages && hasPdfJs) {
          canvasWrap.classList.remove('hidden');
          const loadingTask = pdfjsLib.getDocument({ url, verbosity: 0 });
          pdfDoc = await loadingTask.promise;
          pageNum = Math.min(pageNum, pdfDoc.numPages) || 1;
          setPageInfo();
          await renderPage(pageNum);
        } else {
          // Fallback to server-rendered PNGs per page
          document.getElementById('prevBtn').disabled = false;
          document.getElementById('nextBtn').disabled = false;
          await renderFallbackPage(pageNum);
        }
      } catch (e) {
        console.error(e);
        // Try image fallback if available via desktop bridge
        try {
          if (window.pywebview?.api?.render_preview_page) {
            useImages = true;
            document.getElementById('prevBtn').disabled = false;
            document.getElementById('nextBtn').disabled = false;
            await renderFallbackPage(pageNum);
            return;
          }
        } catch {}
        try {
          const msg = (e && (e.message || e.toString && e.toString())) || '';
          alert('Failed to load PDF preview.' + (msg ? '\n' + msg : ''));
        } catch (_) {
          alert('Failed to load PDF preview.');
        }
      }
    }

    function setZoomLabel() {
      const z = Math.round(zoom * 100);
      const el = document.getElementById('zoomLabel');
      if (el) el.textContent = z + '%';
    }

    async function renderFallbackPage(num) {
      if (!window.pywebview?.api?.render_preview_page) return;
      // Ensure we know page count
      try {
        if (!window.__pageCount) {
          const info = await window.pywebview.api.get_preview_page_count();
          window.__pageCount = info?.count || 1;
        }
      } catch {}
      pageNum = Math.max(1, Math.min(num, window.__pageCount || 1));
      setPageInfo();
      const w = (canvasWrap.clientWidth - 32) * zoom;
      const h = Math.max(300, window.innerHeight * 0.75) * zoom;
      const res = await window.pywebview.api.render_preview_page(pageNum - 1, Math.max(200, Math.round(w)), Math.max(200, Math.round(h)));
      console.log('[preview] renderFallbackPage', { pageNum, res });
      imgPage.src = res.data_url;
      imgPage.style.width = res.width_px + 'px';
      imgPage.style.height = res.height_px + 'px';
      imgPage.classList.remove('hidden');
      // Ensure overlay sits above and is interactive even if CSS fails to load
      overlay.style.zIndex = '30';
      overlay.style.pointerEvents = 'auto';
      // Size overlay to match
      overlay.style.width = res.width_px + 'px';
      overlay.style.height = res.height_px + 'px';
      overlay.style.left = '50%';
      overlay.style.top = '50%';
      overlay.style.transform = 'translate(-50%, -50%)';
      // Draw overlay using returned display size
      drawOverlay(pageNum, res.width_px, res.height_px, { wpt: res.page_width_pts, hpt: res.page_height_pts });
    }

    async function renderPage(num) {
      if (!pdfDoc) return;
      isRendering = true;

      const page = await pdfDoc.getPage(num);
      // Fit-to-width scaling based on container size
      const container = document.getElementById('canvasWrap');
      const viewport = page.getViewport({ scale: 1 });
      const base = Math.min(
        (container.clientWidth - 32) / viewport.width, // padding allowance
        (container.clientHeight - 32) / viewport.height
      ) || 1.25;
      const vp = page.getViewport({ scale: base * zoom });
      canvas.width = vp.width | 0;
      canvas.height = vp.height | 0;

      const renderContext = { canvasContext: ctx, viewport: vp };
      await page.render(renderContext).promise;

      // Position overlay and text layer to align with the rendered canvas
      // so hit-testing/dragging match the page location even when the
      // canvas is centered within its container.
      if (overlay) {
        overlay.style.width = vp.width + 'px';
        overlay.style.height = vp.height + 'px';
        overlay.style.left = '50%';
        overlay.style.top = '50%';
        overlay.style.transform = 'translate(-50%, -50%)';
        overlay.style.zIndex = '30';
        overlay.style.pointerEvents = 'auto';
      }

      // Optional text layer (selection/search visuals)
      const textLayerDiv = document.getElementById('textLayer');
      if (textLayerDiv) {
        textLayerDiv.innerHTML = ''; // clear
        textLayerDiv.style.width = vp.width + 'px';
        textLayerDiv.style.height = vp.height + 'px';
        textLayerDiv.style.left = '50%';
        textLayerDiv.style.top = '50%';
        textLayerDiv.style.transform = 'translate(-50%, -50%)';
        const textContent = await page.getTextContent();
        pdfjsLib.renderTextLayer({
          textContentSource: textContent,
          container: textLayerDiv,
          viewport: vp,
        });
      }

      isRendering = false;
      if (pendingPage !== null) {
        const p = pendingPage; pendingPage = null; renderPage(p);
      }
      setPageInfo();
      try { drawOverlay(num, vp.width, vp.height, null); } catch (e) { console.error(e); }
    }

    function queueRender(num) {
      if (isRendering) { pendingPage = num; }
      else { renderPage(num); }
    }

    // Controls
    document.getElementById('prevBtn').addEventListener('click', async () => {
      if (pageNum <= 1) return;
      pageNum--;
      if (!useImages && hasPdfJs) queueRender(pageNum); else await renderFallbackPage(pageNum);
    });

    document.getElementById('nextBtn').addEventListener('click', async () => {
      if (!useImages && hasPdfJs) {
        if (!pdfDoc || pageNum >= pdfDoc.numPages) return;
        pageNum++; queueRender(pageNum);
      } else {
        if (window.__pageCount && pageNum >= window.__pageCount) return;
        pageNum++; await renderFallbackPage(pageNum);
      }
    });

    document.getElementById('refreshBtn').addEventListener('click', async () => {
      await refreshPreview();
    });

    document.getElementById('addBoxBtn').addEventListener('click', async () => {
      try {
        if (!overlayMeta) {
          await loadOverlayMeta();
        }
        const currentPage = Math.max(0, (pageNum || 1) - 1);
        let pageInfo = overlayMeta && overlayMeta.pages ? overlayMeta.pages.find(p => p.index === currentPage) : null;
        if (!pageInfo) {
          pageInfo = { width: canvasWrap?.clientWidth || 600, height: canvasWrap?.clientHeight || 800 };
        }
        const res = await createManualNoteAt(currentPage, (pageInfo.width || 600) / 2, (pageInfo.height || 800) / 2);
        if (!res || !res.uid) {
          alert('Manual note request failed. Make sure manual mode is active.');
        } else {
          alert('Manual note created: ' + JSON.stringify(res));
        }
      } catch (err) {
        console.error('[preview] addBoxBtn failed', err);
        alert('Manual note request failed.');
      }
    });

    // Zoom controls
    function clampZoom(z) { return Math.min(ZOOM_MAX, Math.max(ZOOM_MIN, z)); }
    async function applyZoom(newZoom) {
      zoom = clampZoom(newZoom);
      setZoomLabel();
      if (!useImages && hasPdfJs) queueRender(pageNum); else await renderFallbackPage(pageNum);
    }
    const $zoomInBtn = document.getElementById('zoomInBtn');
    const $zoomOutBtn = document.getElementById('zoomOutBtn');
    const $zoomFitBtn = document.getElementById('zoomFitBtn');
    if ($zoomInBtn) $zoomInBtn.addEventListener('click', async () => { await applyZoom(zoom + ZOOM_STEP); });
    if ($zoomOutBtn) $zoomOutBtn.addEventListener('click', async () => { await applyZoom(zoom - ZOOM_STEP); });
    if ($zoomFitBtn) $zoomFitBtn.addEventListener('click', async () => { await applyZoom(1.0); });

    

    document.getElementById('freezeToggle').addEventListener('change', (e) => {
      const on = e.target.checked;
      notifyFreezeLayout(on);
      document.getElementById('canvasWrap').classList.toggle('dragging', on);
    });

    document.getElementById('autoToggle').addEventListener('change', (e) => {
      // If you do post-drag re-rendering, wire it here
      if (window.pywebview?.api?.set_auto_refresh) {
        try { window.pywebview.api.set_auto_refresh(!!e.target.checked); } catch {}
      }
    });

    document.getElementById('exportBtn').addEventListener('click', async () => {
      const suggested = "annotated.pdf";
      const path = await browseForPath(suggested);
      if (!path) return;
      const ok = await exportEditedPdf(path);
      if (ok) {
        alert("Export complete:\n" + path);
      }
    });

    // Edit toolbar logic
    const $mainTb = document.getElementById('mainToolbar');
    const $editTb = document.getElementById('editToolbar');
    const $editBackBtn = document.getElementById('editBackBtn');
    const $saveEditBtn = document.getElementById('saveEditBtn');
    const $cancelEditBtn = document.getElementById('cancelEditBtn');
    const $editTextInput = document.getElementById('editTextInput');
    const $editColorInput = document.getElementById('editColorInput');
    const $editFontSizeInput = document.getElementById('editFontSizeInput');
    const $editNoteId = document.getElementById('editNoteId');

    function enterEditMode(uid) {
      selectedUid = uid;
      try {
        const p = (overlayMeta?.placements || []).find(x => x.uid === uid);
        $editTextInput.value = (p && p.explanation) || '';
        $editColorInput.value = (p && p.color) || '#ff9800';
      } catch {}
      // If we had a way to fetch font size per note, set it; default to 9
      $editFontSizeInput.value = $editFontSizeInput.value || '9';
      $editNoteId.textContent = uid ? ('#' + uid) : '';
      $mainTb.classList.add('hidden');
      $editTb.classList.remove('hidden');
    }
    function exitEditMode() {
      $editTb.classList.add('hidden');
      $mainTb.classList.remove('hidden');
      $editNoteId.textContent = '';
    }
    $editBackBtn.addEventListener('click', exitEditMode);
    $cancelEditBtn.addEventListener('click', exitEditMode);
    $saveEditBtn.addEventListener('click', async () => {
      if (!selectedUid) { exitEditMode(); return; }
      const uid = selectedUid;
      const text = $editTextInput.value || '';
      const color = $editColorInput.value || '';
      const fsz = parseFloat($editFontSizeInput.value || '0');
      try {
        if (window.pywebview?.api?.set_note_text) {
          await window.pywebview.api.set_note_text(uid, text);
        }
        if (window.pywebview?.api?.set_note_color && color) {
          await window.pywebview.api.set_note_color(uid, color);
          // Update outline immediately
          const el = overlay.querySelector('[data-uid="'+uid+'"]');
          if (el) el.style.borderColor = color;
        }
        if (window.pywebview?.api?.set_note_fontsize && fsz > 0) {
          await window.pywebview.api.set_note_fontsize(uid, fsz);
        }
        if (document.getElementById('autoToggle')?.checked) {
          await refreshPreview();
        }
      } catch (e) { console.error(e); }
      exitEditMode();
    });

    

    // Keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if (e.target && /input|textarea|select/i.test(e.target.tagName)) return;
      if (e.key === 'ArrowLeft') { document.getElementById('prevBtn').click(); }
      if (e.key === 'ArrowRight') { document.getElementById('nextBtn').click(); }
      if (e.key.toLowerCase() === 'r') { document.getElementById('refreshBtn').click(); }
      if (e.key.toLowerCase() === 'e') { document.getElementById('exportBtn').click(); }
      const isMod = e.ctrlKey || e.metaKey;
      if (isMod && (e.key === '+' || e.key === '=')) { e.preventDefault(); applyZoom(zoom + ZOOM_STEP); }
      if (isMod && (e.key === '-' || e.key === '_')) { e.preventDefault(); applyZoom(zoom - ZOOM_STEP); }
      if (isMod && (e.key === '0')) { e.preventDefault(); applyZoom(1.0); }
    });

    // Mouse wheel zoom (with Ctrl/⌘)
    canvasWrap.addEventListener('wheel', async (e) => {
      if (!(e.ctrlKey || e.metaKey)) return;
      e.preventDefault();
      const dir = e.deltaY > 0 ? -1 : 1; // down = zoom out
      await applyZoom(zoom + dir * (ZOOM_STEP * 2));
    }, { passive: false });

    // Auto-resize handling
    let resizeTimer = null;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        if (!useImages && hasPdfJs) {
          if (!pdfDoc) return;
          queueRender(pageNum);
        } else if (window.pywebview?.api?.render_preview_page) {
          renderFallbackPage(pageNum);
        }
      }, 120);
    });

    async function refreshPreview() {
      try {
        // Prefer desktop bridge path when available (more reliable offline)
        if (window.pywebview?.api) {
          useImages = true;
          await loadOverlayMeta();
          try { console.log('[preview] overlayMeta', { pages: overlayMeta?.pages?.length || 0, placements: overlayMeta?.placements?.length || 0 }); } catch {}
          await renderFallbackPage(pageNum);
          return;
        }

        // Web fallback with PDF.js (uses remote sample if no bridge)
        const url = await getPreviewUrl();
        const finalUrl = url.startsWith('data:') ? url : (url + (url.includes('?') ? '&' : '?') + '_=' + Date.now());
        await loadDocument(finalUrl);
        await loadOverlayMeta();
        try { console.log('[preview] overlayMeta', { pages: overlayMeta?.pages?.length || 0, placements: overlayMeta?.placements?.length || 0 }); } catch {}
        if (!useImages && hasPdfJs && pdfDoc) {
          queueRender(pageNum);
        } else {
          await renderFallbackPage(pageNum);
        }
      } catch (e) {
        console.error(e);
        try {
          const msg = (e && (e.message || e.toString && e.toString())) || '';
          alert('Failed to load PDF preview.' + (msg ? '\n' + msg : ''));
        } catch (_) {
          alert('Failed to load PDF preview.');
        }
      }
    }

    // Initial load
    (async function init() {
      try { setZoomLabel(); } catch {}
      await refreshPreview();
      // Ask backend if we should start frozen
      try {
        if (window.pywebview?.api?.get_freeze_layout) {
          const on = await window.pywebview.api.get_freeze_layout();
          const cb = document.getElementById('freezeToggle');
          cb.checked = !!on; cb.dispatchEvent(new Event('change'));
        }
      } catch {}
      window.addEventListener('error', (e) => console.error('[preview] window error', e?.message, e?.error));
      window.addEventListener('unhandledrejection', (e) => console.error('[preview] unhandled', e?.reason));
    })();

    // If the bridge becomes ready later, try to refresh from the real source
    document.addEventListener('pywebviewready', () => {
      try { refreshPreview(); } catch {}
    });

    // -------- Overlay logic (drag + edit) --------
    let overlayMeta = null;
    // Robustly fetch overlay meta, waiting briefly for the desktop bridge
    async function getPreviewMeta() {
      const tryApi = async () => {
        try {
          if (window.pywebview?.api?.get_preview_meta) {
            return await window.pywebview.api.get_preview_meta();
          }
        } catch (e) {
          // fall through to retry
        }
        return null;
      };

      let meta = await tryApi();
      if (!meta) {
        const start = Date.now();
        while (Date.now() - start < 2500) { // wait up to 2.5s for injection
          await new Promise(r => setTimeout(r, 150));
          meta = await tryApi();
          if (meta) break;
        }
      }
      return meta;
    }

    async function loadOverlayMeta() {
      overlayMeta = await getPreviewMeta();
    }

    function px(n) { return Math.round(n) + 'px'; }

    function isFrozen() {
      const cb = document.getElementById('freezeToggle');
      return !!(cb && cb.checked);
    }

    function drawOverlay(num, canvasW, canvasH, pts) {
      if (!overlayMeta) { if (overlay) overlay.innerHTML=''; return; }
      const pageIndex = (num - 1);
      const pageInfo = overlayMeta.pages?.find(p => p.index === pageIndex) || (pts ? { width: pts.wpt, height: pts.hpt } : null);
      if (!overlay) return;
      overlay.innerHTML = '';
      if (!pageInfo) return;
      const sx = canvasW / pageInfo.width;
      const sy = canvasH / pageInfo.height;
      overlay.style.width = px(canvasW);
      overlay.style.height = px(canvasH);

      const items = (overlayMeta.placements || []).filter(p => p.page_index === pageIndex);
      items.forEach(p => {
        const rect = p.note_rect || p.rect;
        if (!rect || rect.length < 4) {
          console.warn('[preview] missing rect for placement', p);
          return;
        }
        let [x0, y0, x1, y1] = rect;
        const el = document.createElement('div');
        el.className = 'absolute border-2 rounded-sm bg-transparent';
        el.style.borderColor = p.color || '#ff9800';
        el.style.left = px(x0 * sx); el.style.top = px(y0 * sy);
        el.style.width = px((x1 - x0) * sx); el.style.height = px((y1 - y0) * sy);
        el.setAttribute('data-uid', p.uid);
        el.setAttribute('data-x0', String(x0));
        el.setAttribute('data-y0', String(y0));
        el.setAttribute('data-x1', String(x1));
        el.setAttribute('data-y1', String(y1));
        el.setAttribute('data-sx', String(sx));
        el.setAttribute('data-sy', String(sy));
        el.setAttribute('title', 'Drag to move. Right-click for actions. Use corner handle to resize.');
        // Resize handle
        const h = document.createElement('div');
        h.className = 'resize-handle';
        h.setAttribute('data-role', 'resize');
        el.appendChild(h);
        overlay.appendChild(el);
      });
    }

    async function createManualNoteAt(pageIndex, pageX, pageY) {
      if (!window.pywebview || !window.pywebview.api || !window.pywebview.api.create_manual_text_box) {
        alert('Manual text boxes are only available in the desktop app.');
        return null;
      }
      try {
        const res = await window.pywebview.api.create_manual_text_box(pageIndex, pageX, pageY);
        console.log('[preview] create_manual_text_box result', res);
        await refreshPreview();
        if (res && res.uid) {
          try { enterEditMode(res.uid); } catch (err) { console.warn(err); }
        }
        return res;
      } catch (e) {
        console.error('[preview] create_manual_text_box failed', e);
        alert('Failed to create manual text box.');
        return null;
      }
    }

    // Selection, dragging, editing via delegation
    let dragState = null;
    overlay.addEventListener('click', (e) => {
      const t = e.target.closest('[data-uid]');
      if (!t) return;
      selectedUid = t.getAttribute('data-uid');
      Array.from(overlay.children).forEach(ch => ch.style.outline = '');
      t.style.outline = '2px dashed #fff';
    });

    // Context menu for note actions
    const ctxMenu = document.getElementById('ctxMenu');
    const ctxEdit = document.getElementById('ctxEditText');
    function hideCtxMenu() { ctxMenu.style.display = 'none'; }
    function showCtxMenu(x, y) {
      ctxMenu.style.left = Math.max(8, x) + 'px';
      ctxMenu.style.top = Math.max(8, y) + 'px';
      ctxMenu.style.display = 'block';
    }
    overlay.addEventListener('contextmenu', (e) => {
      const t = e.target.closest('[data-uid]');
      if (!t) return;
      e.preventDefault();
      selectedUid = t.getAttribute('data-uid');
      Array.from(overlay.children).forEach(ch => ch.style.outline = '');
      t.style.outline = '2px dashed #fff';
      showCtxMenu(e.clientX, e.clientY);
    });
    ctxEdit.addEventListener('click', () => {
      hideCtxMenu();
      if (selectedUid) enterEditMode(selectedUid);
    });
    window.addEventListener('click', (e) => {
      if (ctxMenu.style.display === 'block' && !ctxMenu.contains(e.target)) hideCtxMenu();
    });
    window.addEventListener('keydown', (e) => { if (e.key === 'Escape') hideCtxMenu(); });

    overlay.addEventListener('mousedown', (e) => {
      if (isFrozen()) return;
      const t = e.target.closest('[data-uid]');
      if (!t) return;
      const onHandle = !!e.target.closest('[data-role="resize"]');
      const uid = t.getAttribute('data-uid');
      const sx = parseFloat(t.getAttribute('data-sx') || '1');
      const sy = parseFloat(t.getAttribute('data-sy') || '1');
      const x0 = parseFloat(t.getAttribute('data-x0') || '0');
      const y0 = parseFloat(t.getAttribute('data-y0') || '0');
      const x1 = parseFloat(t.getAttribute('data-x1') || '0');
      const y1 = parseFloat(t.getAttribute('data-y1') || '0');
      dragState = { el: t, uid, sx, sy, x0, y0, x1, y1, startX: e.clientX, startY: e.clientY, mode: (onHandle ? 'resize' : 'move') };
      e.preventDefault();
    });

    window.addEventListener('mousemove', (e) => {
      if (!dragState) return;
      const { el, sx, sy, startX, startY, x0, y0, x1, y1, mode } = dragState;
      const dx = (e.clientX - startX) / sx;
      const dy = (e.clientY - startY) / sy;
      if (mode === 'resize') {
        // Keep top-left fixed, move bottom-right
        const nx1 = Math.max(x0 + 10, x1 + dx);
        const ny1 = Math.max(y0 + 10, y1 + dy);
        el.style.width = px((nx1 - x0) * sx);
        el.style.height = px((ny1 - y0) * sy);
        el.setAttribute('data-x1', String(nx1));
        el.setAttribute('data-y1', String(ny1));
      } else {
        const nx0 = x0 + dx, ny0 = y0 + dy, nx1 = x1 + dx, ny1 = y1 + dy;
        el.style.left = px(nx0 * sx); el.style.top = px(ny0 * sy);
        el.setAttribute('data-x0', String(nx0));
        el.setAttribute('data-y0', String(ny0));
        el.setAttribute('data-x1', String(nx1));
        el.setAttribute('data-y1', String(ny1));
      }
    });

    window.addEventListener('mouseup', async () => {
      if (!dragState) return;
      const { uid, x0, y0, x1, y1 } = {
        uid: dragState.uid,
        x0: parseFloat(dragState.el.getAttribute('data-x0') || '0'),
        y0: parseFloat(dragState.el.getAttribute('data-y0') || '0'),
        x1: parseFloat(dragState.el.getAttribute('data-x1') || '0'),
        y1: parseFloat(dragState.el.getAttribute('data-y1') || '0'),
      };
      dragState = null;
      try {
        if (window.pywebview?.api?.set_note_rect) {
          await window.pywebview.api.set_note_rect(uid, x0, y0, x1, y1);
        }
        if (document.getElementById('autoToggle')?.checked) {
          await refreshPreview();
        }
      } catch {}
    });

    // Keyboard shortcuts for selected element
    window.addEventListener('keydown', async (e) => {
      if (!selectedUid) return;
      if (e.target && /input|textarea|select/i.test(e.target.tagName)) return;
      try {
        if (e.key.toLowerCase() === 'f') {
          const v = prompt('Set font size (pt):');
          if (v && window.pywebview?.api?.set_note_fontsize) {
            await window.pywebview.api.set_note_fontsize(selectedUid, parseFloat(v));
            await refreshPreview();
          }
        } else if (e.key.toLowerCase() === 'c') {
          const v = prompt('Set text color (#RRGGBB or named color):');
          if (v && window.pywebview?.api?.set_note_color) {
            await window.pywebview.api.set_note_color(selectedUid, v.trim());
            await refreshPreview();
          }
        } else if (e.key.toLowerCase() === 'r') {
          const v = prompt('Set rotation (degrees):');
          if (v && window.pywebview?.api?.set_note_rotation) {
            await window.pywebview.api.set_note_rotation(selectedUid, parseFloat(v));
            await refreshPreview();
          }
        }
      } catch {}
    });
  </script>
  <script>
    // Settings button -> open settings page via desktop bridge
    (function(){
      var sbtn = document.getElementById('btnSettings');
      function openSettings(e){
        if (e && e.preventDefault) e.preventDefault();
        console.log('[settings] click');
        try {
          var api = (window.pywebview && window.pywebview.api) ? window.pywebview.api : null;
          console.log('[settings] api?', !!api);
          function fallback(){
            try {
              if (api && api.get_settings_url) {
                var u = api.get_settings_url();
                console.log('[settings] fallback url', u);
                if (u) { window.location.href = u; return; }
              }
            } catch(err) { try { console.error(err); } catch(_){} }
            alert('Failed to open settings.');
          }
          if (api && api.open_settings) {
            console.log('[settings] calling open_settings');
            var r = api.open_settings();
            if (r && typeof r.then === 'function') {
              r.then(function(ok){ console.log('[settings] open_settings result', ok); if (!ok) fallback(); })
               .catch(function(e){ console.log('[settings] open_settings error', e); fallback(); });
            } else if (!r) {
              console.log('[settings] open_settings returned false');
              fallback();
            }
          } else {
            fallback();
          }
        } catch(err) { try { console.error(err); } catch(_){} }
      }
      if (sbtn && sbtn.addEventListener) sbtn.addEventListener('click', openSettings);
      else if (sbtn && sbtn.attachEvent) sbtn.attachEvent('onclick', openSettings);
    })();
  </script>
  <script src="assets/js/guided_tour.js" defer></script>
  <script src="assets/js/preview.js?v=3" defer></script>
</body>
</html>
